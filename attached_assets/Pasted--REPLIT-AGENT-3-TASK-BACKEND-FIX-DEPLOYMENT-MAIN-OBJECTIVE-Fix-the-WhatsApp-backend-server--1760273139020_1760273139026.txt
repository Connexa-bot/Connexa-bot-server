# REPLIT AGENT 3 TASK - BACKEND FIX & DEPLOYMENT

## MAIN OBJECTIVE
Fix the WhatsApp backend server, ensure all endpoints work correctly, handle state management, test thoroughly, and deploy on Replit with proper documentation.

---

## PHASE 1: ANALYZE & FIX BACKEND CODE

### 1.1 Locate and Review Backend Files
- Find the main server file (likely `server.js`, `index.js`, or `app.js`)
- Review all API endpoint definitions
- Check authentication/session management code
- Review WhatsApp Baileys integration

### 1.2 Fix Critical Issues

#### A. Fix State Synchronization Errors
The logs show: `"tried remove, but no previous op"` errors in Baileys state sync.

**Add this helper function:**
```javascript
// Add to your backend code
const fs = require('fs').promises;
const path = require('path');

async function clearSessionState(phoneNumber, fullReset = false) {
  try {
    const sessionDir = path.join(__dirname, 'auth_info_baileys', phoneNumber);
    
    if (fullReset) {
      // Complete reset - requires re-authentication
      await fs.rm(sessionDir, { recursive: true, force: true });
      console.log(`ðŸ—‘ï¸ Full session cleared for ${phoneNumber}`);
    } else {
      // Partial reset - only clear sync state
      const files = await fs.readdir(sessionDir);
      for (const file of files) {
        if (file.startsWith('app-state-sync-')) {
          await fs.unlink(path.join(sessionDir, file));
          console.log(`ðŸ—‘ï¸ Deleted sync file: ${file}`);
        }
      }
      console.log(`ðŸ§¹ Sync state cleared for ${phoneNumber}`);
    }
    return true;
  } catch (error) {
    console.error('Clear state error:', error.message);
    return false;
  }
}

// Add endpoint to clear state manually
app.post('/api/clear-state/:phoneNumber', async (req, res) => {
  const { phoneNumber } = req.params;
  const { fullReset } = req.query;
  
  const success = await clearSessionState(phoneNumber, fullReset === 'true');
  
  if (success) {
    // Remove from active sessions if full reset
    if (fullReset === 'true') {
      sessions.delete(phoneNumber);
    }
    res.json({ success: true, message: 'State cleared successfully' });
  } else {
    res.status(500).json({ success: false, message: 'Failed to clear state' });
  }
});
```

#### B. Fix Status Updates Endpoint (Currently Returning 500)
```javascript
app.get('/api/status-updates/:phoneNumber', async (req, res) => {
  try {
    const { phoneNumber } = req.params;
    const session = sessions.get(phoneNumber);
    
    if (!session?.sock) {
      return res.status(200).json({ 
        success: true,
        statusUpdates: [],
        message: 'No active session'
      });
    }
    
    // Fetch status updates safely
    let statusUpdates = [];
    try {
      // Add your status fetching logic here
      // Example: statusUpdates = await fetchStatuses(session.sock);
      statusUpdates = []; // Default empty for now
    } catch (err) {
      console.error('Status fetch error:', err);
    }
    
    res.json({ 
      success: true,
      statusUpdates,
      count: statusUpdates.length
    });
    
  } catch (error) {
    console.error('Status updates endpoint error:', error);
    res.status(200).json({ 
      success: false,
      statusUpdates: [],
      error: error.message
    });
  }
});
```

#### C. Fix Chats Endpoint (Returning Empty/304)
```javascript
app.get('/api/chats/:phoneNumber', async (req, res) => {
  try {
    const { phoneNumber } = req.params;
    const session = sessions.get(phoneNumber);
    
    if (!session?.sock) {
      return res.status(200).json({ 
        success: false,
        chats: [],
        message: 'No active session'
      });
    }
    
    // Force fetch chats from WhatsApp
    let chats = [];
    try {
      const allChats = await session.sock.groupFetchAllParticipating();
      chats = Object.values(allChats);
      
      // Also get direct message chats
      const store = session.store || {};
      if (store.chats) {
        chats = [...chats, ...Object.values(store.chats)];
      }
      
      console.log(`ðŸ“± Fetched ${chats.length} chats for ${phoneNumber}`);
    } catch (err) {
      console.error('Chats fetch error:', err);
    }
    
    res.json({ 
      success: true,
      chats,
      count: chats.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Chats endpoint error:', error);
    res.status(500).json({ 
      success: false,
      chats: [],
      error: error.message
    });
  }
});
```

#### D. Improve Connection Handler
```javascript
sock.ev.on('connection.update', async (update) => {
  const { connection, lastDisconnect, qr } = update;
  
  if (qr) {
    console.log('ðŸ“± QR Code generated');
    session.qrCode = qr;
  }
  
  if (connection === 'close') {
    const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
    console.log('âŒ Connection closed. Reconnecting:', shouldReconnect);
    
    if (shouldReconnect) {
      // Wait before reconnecting
      setTimeout(() => connectWhatsApp(phoneNumber), 3000);
    } else {
      sessions.delete(phoneNumber);
      await clearSessionState(phoneNumber, true);
    }
  }
  
  if (connection === 'open') {
    console.log('âœ… Connection OPEN');
    session.connected = true;
    
    // Force sync chats on connection
    try {
      const allChats = await sock.groupFetchAllParticipating();
      session.chats = Object.values(allChats);
      console.log(`ðŸ“± Synced ${session.chats.length} chats`);
    } catch (err) {
      console.error('Initial chat sync failed:', err);
    }
  }
});
```

---

## PHASE 2: COMPREHENSIVE ENDPOINT TESTING

### 2.1 Create Test Script
Create a file called `test-endpoints.sh`:

```bash
#!/bin/bash

# Test Endpoints Script
BASE_URL="http://localhost:3000"
PHONE="2349154347487"

echo "ðŸ§ª TESTING BACKEND ENDPOINTS"
echo "================================"

# Test 1: Health Check
echo -e "\n1ï¸âƒ£ Testing Health Check..."
curl -s "$BASE_URL/health" | jq '.'

# Test 2: Connect WhatsApp
echo -e "\n2ï¸âƒ£ Testing WhatsApp Connect..."
curl -s -X POST "$BASE_URL/api/connect" \
  -H "Content-Type: application/json" \
  -d "{\"phoneNumber\":\"$PHONE\"}" | jq '.'

# Test 3: Get QR Code
echo -e "\n3ï¸âƒ£ Testing QR Code..."
curl -s "$BASE_URL/api/qr/$PHONE" | jq '.'

# Test 4: Check Status
echo -e "\n4ï¸âƒ£ Testing Connection Status..."
curl -s "$BASE_URL/api/status/$PHONE" | jq '.'

# Wait for user to scan QR
echo -e "\nâ³ Please scan QR code and press Enter when connected..."
read

# Test 5: Get Chats
echo -e "\n5ï¸âƒ£ Testing Get Chats..."
curl -s "$BASE_URL/api/chats/$PHONE" | jq '.'

# Test 6: Get Calls
echo -e "\n6ï¸âƒ£ Testing Get Calls..."
curl -s "$BASE_URL/api/calls/$PHONE" | jq '.'

# Test 7: Get Status Updates
echo -e "\n7ï¸âƒ£ Testing Status Updates..."
curl -s "$BASE_URL/api/status-updates/$PHONE" | jq '.'

# Test 8: Send Message
echo -e "\n8ï¸âƒ£ Testing Send Message..."
curl -s -X POST "$BASE_URL/api/send-message" \
  -H "Content-Type: application/json" \
  -d "{
    \"phoneNumber\":\"$PHONE\",
    \"to\":\"$PHONE\",
    \"message\":\"Test message from backend\"
  }" | jq '.'

# Test 9: Clear State (Partial)
echo -e "\n9ï¸âƒ£ Testing Clear State (Partial)..."
curl -s -X POST "$BASE_URL/api/clear-state/$PHONE" | jq '.'

# Test 10: Disconnect
echo -e "\nðŸ”Ÿ Testing Disconnect..."
curl -s -X POST "$BASE_URL/api/disconnect/$PHONE" | jq '.'

echo -e "\nâœ… ALL TESTS COMPLETED"
```

### 2.2 Run Tests
```bash
chmod +x test-endpoints.sh
./test-endpoints.sh
```

---

## PHASE 3: CREATE API DOCUMENTATION FILE

Create `API.js` file with all working endpoints:

```javascript
/**
 * CONNEXA-BOT API ENDPOINTS
 * 
 * Base URL (Development): http://localhost:3000
 * Base URL (Production): https://your-replit-app.replit.app
 */

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000';

export const API_ENDPOINTS = {
  
  // ========== CONNECTION ENDPOINTS ==========
  
  /**
   * Connect WhatsApp Session
   * POST /api/connect
   * Body: { phoneNumber: string }
   * Returns: { success: boolean, message: string, qrCode?: string }
   */
  CONNECT: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/connect`,
    method: 'POST',
    body: { phoneNumber }
  }),
  
  /**
   * Get QR Code
   * GET /api/qr/:phoneNumber
   * Returns: { qrCode: string | null, connected: boolean }
   */
  GET_QR: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/qr/${phoneNumber}`,
    method: 'GET'
  }),
  
  /**
   * Check Connection Status
   * GET /api/status/:phoneNumber
   * Returns: { connected: boolean, user?: object }
   */
  GET_STATUS: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/status/${phoneNumber}`,
    method: 'GET'
  }),
  
  /**
   * Disconnect Session
   * POST /api/disconnect/:phoneNumber
   * Returns: { success: boolean }
   */
  DISCONNECT: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/disconnect/${phoneNumber}`,
    method: 'POST'
  }),
  
  // ========== DATA ENDPOINTS ==========
  
  /**
   * Get All Chats
   * GET /api/chats/:phoneNumber
   * Returns: { success: boolean, chats: array, count: number }
   */
  GET_CHATS: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/chats/${phoneNumber}`,
    method: 'GET'
  }),
  
  /**
   * Get Messages from Specific Chat
   * GET /api/messages/:phoneNumber/:chatId
   * Returns: { success: boolean, messages: array }
   */
  GET_MESSAGES: (phoneNumber, chatId) => ({
    url: `${API_BASE_URL}/api/messages/${phoneNumber}/${chatId}`,
    method: 'GET'
  }),
  
  /**
   * Get Call History
   * GET /api/calls/:phoneNumber
   * Returns: { success: boolean, calls: array }
   */
  GET_CALLS: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/calls/${phoneNumber}`,
    method: 'GET'
  }),
  
  /**
   * Get Status Updates
   * GET /api/status-updates/:phoneNumber
   * Returns: { success: boolean, statusUpdates: array }
   */
  GET_STATUS_UPDATES: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/status-updates/${phoneNumber}`,
    method: 'GET'
  }),
  
  // ========== ACTION ENDPOINTS ==========
  
  /**
   * Send Text Message
   * POST /api/send-message
   * Body: { phoneNumber: string, to: string, message: string }
   * Returns: { success: boolean, messageId: string }
   */
  SEND_MESSAGE: (phoneNumber, to, message) => ({
    url: `${API_BASE_URL}/api/send-message`,
    method: 'POST',
    body: { phoneNumber, to, message }
  }),
  
  /**
   * Make Voice Call
   * POST /api/make-call
   * Body: { phoneNumber: string, to: string }
   * Returns: { success: boolean }
   */
  MAKE_CALL: (phoneNumber, to) => ({
    url: `${API_BASE_URL}/api/make-call`,
    method: 'POST',
    body: { phoneNumber, to }
  }),
  
  // ========== ADMIN ENDPOINTS ==========
  
  /**
   * Clear Session State
   * POST /api/clear-state/:phoneNumber?fullReset=false
   * Returns: { success: boolean, message: string }
   */
  CLEAR_STATE: (phoneNumber, fullReset = false) => ({
    url: `${API_BASE_URL}/api/clear-state/${phoneNumber}?fullReset=${fullReset}`,
    method: 'POST'
  }),
  
  /**
   * Health Check
   * GET /health
   * Returns: { status: string, uptime: number }
   */
  HEALTH: () => ({
    url: `${API_BASE_URL}/health`,
    method: 'GET'
  })
};

// Helper function to make API calls
export const callAPI = async (endpoint) => {
  try {
    const response = await fetch(endpoint.url, {
      method: endpoint.method,
      headers: {
        'Content-Type': 'application/json',
      },
      body: endpoint.body ? JSON.stringify(endpoint.body) : undefined
    });
    
    return await response.json();
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
};

// Example usage:
// import { API_ENDPOINTS, callAPI } from './API';
// const result = await callAPI(API_ENDPOINTS.GET_CHATS('2349154347487'));

export default API_ENDPOINTS;
```

---

## PHASE 4: CLEANUP UNNECESSARY FILES

Delete these file types:
- `*.md` (except README.md if it's important)
- `*.log`
- `.env.example` (if exists)
- Any test files not needed in production
- Old backup files
- Unused dependencies

```bash
# Run this cleanup
find . -name "*.md" ! -name "README.md" -type f -delete
find . -name "*.log" -type f -delete
find . -name "*backup*" -type f -delete
find . -name "*old*" -type f -delete
```

---

## PHASE 5: DEPLOY ON REPLIT

### 5.1 Create `.replit` Configuration
```toml
run = "node server.js"
language = "nodejs"

[nix]
channel = "stable-22_11"

[deployment]
run = ["sh", "-c", "node server.js"]
deploymentTarget = "cloudrun"

[[ports]]
localPort = 3000
externalPort = 80
```

### 5.2 Create `replit.nix` 
```nix
{ pkgs }: {
  deps = [
    pkgs.nodejs-18_x
    pkgs.nodePackages.typescript
    pkgs.nodePackages.typescript-language-server
  ];
}
```

### 5.3 Update `package.json`
```json
{
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "./test-endpoints.sh"
  }
}
```

### 5.4 Deploy Steps
1. Click "Deploy" button in Replit
2. Choose "Autoscale" deployment
3. Set environment variables in Secrets tab
4. Click "Deploy"

---

## PHASE 6: ENVIRONMENT CONFIGURATION GUIDE

### 6.1 Adding OpenAI API Key

#### In Replit:
1. Go to "Tools" â†’ "Secrets" (or lock icon in sidebar)
2. Add new secret:
   - Key: `OPENAI_API_KEY`
   - Value: `sk-your-openai-api-key-here`
3. Click "Add Secret"

#### In Code:
```javascript
// Access in your backend
const openai = require('openai');

const openaiClient = new openai.OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});
```

#### In `.env` file (local development):
```bash
OPENAI_API_KEY=sk-your-openai-api-key-here
PORT=3000
NODE_ENV=development
```

### 6.2 All Required Environment Variables
```bash
# OpenAI Configuration
OPENAI_API_KEY=sk-xxxxx

# Server Configuration
PORT=3000
NODE_ENV=production

# WhatsApp Configuration (if needed)
WHATSAPP_SESSION_TIMEOUT=300000

# Optional: Database
DATABASE_URL=your-database-url
```

---

## PHASE 7: ACCESSING REPLIT SHELL & MANUAL STATE MANAGEMENT

### 7.1 Access Shell in Replit
1. Click "Shell" tab at the bottom of Replit
2. Or press `Ctrl + Shift + S` (Windows/Linux) or `Cmd + Shift + S` (Mac)

### 7.2 Manual State Deletion Commands

#### View Current Sessions
```bash
# List all session directories
ls -la auth_info_baileys/

# Check specific session
ls -la auth_info_baileys/2349154347487/
```

#### Delete Sync State Only (Keep Authentication)
```bash
# Delete only sync files - won't require re-authentication
rm auth_info_baileys/2349154347487/app-state-sync-*.json

# Verify deletion
ls auth_info_baileys/2349154347487/
```

#### Complete Session Reset (Requires Re-authentication)
```bash
# Delete entire session folder
rm -rf auth_info_baileys/2349154347487/

# Or delete all sessions
rm -rf auth_info_baileys/
```

#### Emergency Full Reset
```bash
# Stop the server first
pkill node

# Delete all session data
rm -rf auth_info_baileys/

# Create fresh directory
mkdir auth_info_baileys

# Restart server
npm start
```

### 7.3 Monitoring Commands
```bash
# View real-time logs
tail -f logs/app.log

# Check server status
ps aux | grep node

# View port usage
netstat -tuln | grep 3000

# Check disk space
df -h
```

### 7.4 Quick Troubleshooting Commands
```bash
# Restart server
pkill node && npm start

# Clear node cache
npm cache clean --force

# Reinstall dependencies
rm -rf node_modules package-lock.json
npm install

# Check Node version
node --version

# Test endpoint from shell
curl http://localhost:3000/health
```

---

## PHASE 8: FINAL CHECKLIST

Before marking as complete, verify:

- [ ] All endpoints return proper responses (no 500 errors)
- [ ] Status updates endpoint fixed
- [ ] Chats endpoint returns data
- [ ] State clearing functionality works
- [ ] Test script runs successfully
- [ ] API.js file created with all endpoints
- [ ] Unnecessary files deleted
- [ ] Deployed on Replit
- [ ] Environment variables configured
- [ ] Health check endpoint responds
- [ ] Connection/disconnection works
- [ ] Documentation complete

---

## PHASE 9: WAIT FOR USER

After completing all phases:

1. **Report** all endpoints tested with results
2. **Provide** the deployed Replit URL
3. **Share** the API.js file content
4. **List** all working endpoints
5. **Wait** for user to share frontend code for cross-checking
6. **Wait** for user to connect and test manually

**DO NOT PROCEED** until user provides frontend code and confirms they're ready to test!

---

## ADDITIONAL NOTES

### Common Issues & Solutions:

**Issue**: Port already in use
```bash
# Kill process on port 3000
lsof -ti:3000 | xargs kill -9
```

**Issue**: Permission denied
```bash
# Fix file permissions
chmod +x test-endpoints.sh
chmod 755 server.js
```

**Issue**: Module not found
```bash
# Reinstall dependencies
npm install
```

**Issue**: Baileys connection fails
```bash
# Clear all state and reconnect
rm -rf auth_info_baileys/
mkdir auth_info_baileys
```

---

## SUCCESS CRITERIA

âœ… Zero 500 errors in logs
âœ… All endpoints return JSON responses
âœ… Chats load successfully
âœ… Status updates work
âœ… Connection stable
âœ… State management working
âœ… Deployed and accessible
âœ… Documentation complete
âœ… Ready for frontend integration

---

**Agent 3: Execute this task step by step. Report progress after each phase. Wait for user confirmation before final deployment.**