# REPLIT AGENT 3 TASK - BACKEND FIX & DEPLOYMENT

## MAIN OBJECTIVE
Fix the WhatsApp backend server, ensure all endpoints work correctly, handle state management, test thoroughly, and deploy on Replit with proper documentation.

---

## PHASE 1: ANALYZE & FIX BACKEND CODE

### 1.1 Locate and Review Backend Files
- Find the main server file (likely `server.js`, `index.js`, or `app.js`)
- Review all API endpoint definitions
- Check authentication/session management code
- Review WhatsApp Baileys integration

### 1.2 Fix Critical Issues

#### A. Fix State Synchronization Errors
The logs show: `"tried remove, but no previous op"` errors in Baileys state sync.

**Add this helper function:**
```javascript
// Add to your backend code
const fs = require('fs').promises;
const path = require('path');

async function clearSessionState(phoneNumber, fullReset = false) {
  try {
    const sessionDir = path.join(__dirname, 'auth_info_baileys', phoneNumber);
    
    if (fullReset) {
      // Complete reset - requires re-authentication
      await fs.rm(sessionDir, { recursive: true, force: true });
      console.log(`🗑️ Full session cleared for ${phoneNumber}`);
    } else {
      // Partial reset - only clear sync state
      const files = await fs.readdir(sessionDir);
      for (const file of files) {
        if (file.startsWith('app-state-sync-')) {
          await fs.unlink(path.join(sessionDir, file));
          console.log(`🗑️ Deleted sync file: ${file}`);
        }
      }
      console.log(`🧹 Sync state cleared for ${phoneNumber}`);
    }
    return true;
  } catch (error) {
    console.error('Clear state error:', error.message);
    return false;
  }
}

// Add endpoint to clear state manually
app.post('/api/clear-state/:phoneNumber', async (req, res) => {
  const { phoneNumber } = req.params;
  const { fullReset } = req.query;
  
  const success = await clearSessionState(phoneNumber, fullReset === 'true');
  
  if (success) {
    // Remove from active sessions if full reset
    if (fullReset === 'true') {
      sessions.delete(phoneNumber);
    }
    res.json({ success: true, message: 'State cleared successfully' });
  } else {
    res.status(500).json({ success: false, message: 'Failed to clear state' });
  }
});
```

#### B. Fix Status Updates Endpoint (Currently Returning 500)
```javascript
app.get('/api/status-updates/:phoneNumber', async (req, res) => {
  try {
    const { phoneNumber } = req.params;
    const session = sessions.get(phoneNumber);
    
    if (!session?.sock) {
      return res.status(200).json({ 
        success: true,
        statusUpdates: [],
        message: 'No active session'
      });
    }
    
    // Fetch status updates safely
    let statusUpdates = [];
    try {
      // Add your status fetching logic here
      // Example: statusUpdates = await fetchStatuses(session.sock);
      statusUpdates = []; // Default empty for now
    } catch (err) {
      console.error('Status fetch error:', err);
    }
    
    res.json({ 
      success: true,
      statusUpdates,
      count: statusUpdates.length
    });
    
  } catch (error) {
    console.error('Status updates endpoint error:', error);
    res.status(200).json({ 
      success: false,
      statusUpdates: [],
      error: error.message
    });
  }
});
```

#### C. Fix Chats Endpoint (Returning Empty/304)
```javascript
app.get('/api/chats/:phoneNumber', async (req, res) => {
  try {
    const { phoneNumber } = req.params;
    const session = sessions.get(phoneNumber);
    
    if (!session?.sock) {
      return res.status(200).json({ 
        success: false,
        chats: [],
        message: 'No active session'
      });
    }
    
    // Force fetch chats from WhatsApp
    let chats = [];
    try {
      const allChats = await session.sock.groupFetchAllParticipating();
      chats = Object.values(allChats);
      
      // Also get direct message chats
      const store = session.store || {};
      if (store.chats) {
        chats = [...chats, ...Object.values(store.chats)];
      }
      
      console.log(`📱 Fetched ${chats.length} chats for ${phoneNumber}`);
    } catch (err) {
      console.error('Chats fetch error:', err);
    }
    
    res.json({ 
      success: true,
      chats,
      count: chats.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Chats endpoint error:', error);
    res.status(500).json({ 
      success: false,
      chats: [],
      error: error.message
    });
  }
});
```

#### D. Improve Connection Handler
```javascript
sock.ev.on('connection.update', async (update) => {
  const { connection, lastDisconnect, qr } = update;
  
  if (qr) {
    console.log('📱 QR Code generated');
    session.qrCode = qr;
  }
  
  if (connection === 'close') {
    const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
    console.log('❌ Connection closed. Reconnecting:', shouldReconnect);
    
    if (shouldReconnect) {
      // Wait before reconnecting
      setTimeout(() => connectWhatsApp(phoneNumber), 3000);
    } else {
      sessions.delete(phoneNumber);
      await clearSessionState(phoneNumber, true);
    }
  }
  
  if (connection === 'open') {
    console.log('✅ Connection OPEN');
    session.connected = true;
    
    // Force sync chats on connection
    try {
      const allChats = await sock.groupFetchAllParticipating();
      session.chats = Object.values(allChats);
      console.log(`📱 Synced ${session.chats.length} chats`);
    } catch (err) {
      console.error('Initial chat sync failed:', err);
    }
  }
});
```

---

## PHASE 2: COMPREHENSIVE ENDPOINT TESTING

### 2.1 Create Test Script
Create a file called `test-endpoints.sh`:

```bash
#!/bin/bash

# Test Endpoints Script
BASE_URL="http://localhost:3000"
PHONE="2349154347487"

echo "🧪 TESTING BACKEND ENDPOINTS"
echo "================================"

# Test 1: Health Check
echo -e "\n1️⃣ Testing Health Check..."
curl -s "$BASE_URL/health" | jq '.'

# Test 2: Connect WhatsApp
echo -e "\n2️⃣ Testing WhatsApp Connect..."
curl -s -X POST "$BASE_URL/api/connect" \
  -H "Content-Type: application/json" \
  -d "{\"phoneNumber\":\"$PHONE\"}" | jq '.'

# Test 3: Get QR Code
echo -e "\n3️⃣ Testing QR Code..."
curl -s "$BASE_URL/api/qr/$PHONE" | jq '.'

# Test 4: Check Status
echo -e "\n4️⃣ Testing Connection Status..."
curl -s "$BASE_URL/api/status/$PHONE" | jq '.'

# Wait for user to scan QR
echo -e "\n⏳ Please scan QR code and press Enter when connected..."
read

# Test 5: Get Chats
echo -e "\n5️⃣ Testing Get Chats..."
curl -s "$BASE_URL/api/chats/$PHONE" | jq '.'

# Test 6: Get Calls
echo -e "\n6️⃣ Testing Get Calls..."
curl -s "$BASE_URL/api/calls/$PHONE" | jq '.'

# Test 7: Get Status Updates
echo -e "\n7️⃣ Testing Status Updates..."
curl -s "$BASE_URL/api/status-updates/$PHONE" | jq '.'

# Test 8: Send Message
echo -e "\n8️⃣ Testing Send Message..."
curl -s -X POST "$BASE_URL/api/send-message" \
  -H "Content-Type: application/json" \
  -d "{
    \"phoneNumber\":\"$PHONE\",
    \"to\":\"$PHONE\",
    \"message\":\"Test message from backend\"
  }" | jq '.'

# Test 9: Clear State (Partial)
echo -e "\n9️⃣ Testing Clear State (Partial)..."
curl -s -X POST "$BASE_URL/api/clear-state/$PHONE" | jq '.'

# Test 10: Disconnect
echo -e "\n🔟 Testing Disconnect..."
curl -s -X POST "$BASE_URL/api/disconnect/$PHONE" | jq '.'

echo -e "\n✅ ALL TESTS COMPLETED"
```

### 2.2 Run Tests
```bash
chmod +x test-endpoints.sh
./test-endpoints.sh
```

---

## PHASE 3: CREATE API DOCUMENTATION FILE

Create `API.js` file with all working endpoints:

```javascript
/**
 * CONNEXA-BOT API ENDPOINTS
 * 
 * Base URL (Development): http://localhost:3000
 * Base URL (Production): https://your-replit-app.replit.app
 */

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000';

export const API_ENDPOINTS = {
  
  // ========== CONNECTION ENDPOINTS ==========
  
  /**
   * Connect WhatsApp Session
   * POST /api/connect
   * Body: { phoneNumber: string }
   * Returns: { success: boolean, message: string, qrCode?: string }
   */
  CONNECT: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/connect`,
    method: 'POST',
    body: { phoneNumber }
  }),
  
  /**
   * Get QR Code
   * GET /api/qr/:phoneNumber
   * Returns: { qrCode: string | null, connected: boolean }
   */
  GET_QR: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/qr/${phoneNumber}`,
    method: 'GET'
  }),
  
  /**
   * Check Connection Status
   * GET /api/status/:phoneNumber
   * Returns: { connected: boolean, user?: object }
   */
  GET_STATUS: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/status/${phoneNumber}`,
    method: 'GET'
  }),
  
  /**
   * Disconnect Session
   * POST /api/disconnect/:phoneNumber
   * Returns: { success: boolean }
   */
  DISCONNECT: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/disconnect/${phoneNumber}`,
    method: 'POST'
  }),
  
  // ========== DATA ENDPOINTS ==========
  
  /**
   * Get All Chats
   * GET /api/chats/:phoneNumber
   * Returns: { success: boolean, chats: array, count: number }
   */
  GET_CHATS: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/chats/${phoneNumber}`,
    method: 'GET'
  }),
  
  /**
   * Get Messages from Specific Chat
   * GET /api/messages/:phoneNumber/:chatId
   * Returns: { success: boolean, messages: array }
   */
  GET_MESSAGES: (phoneNumber, chatId) => ({
    url: `${API_BASE_URL}/api/messages/${phoneNumber}/${chatId}`,
    method: 'GET'
  }),
  
  /**
   * Get Call History
   * GET /api/calls/:phoneNumber
   * Returns: { success: boolean, calls: array }
   */
  GET_CALLS: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/calls/${phoneNumber}`,
    method: 'GET'
  }),
  
  /**
   * Get Status Updates
   * GET /api/status-updates/:phoneNumber
   * Returns: { success: boolean, statusUpdates: array }
   */
  GET_STATUS_UPDATES: (phoneNumber) => ({
    url: `${API_BASE_URL}/api/status-updates/${phoneNumber}`,
    method: 'GET'
  }),
  
  // ========== ACTION ENDPOINTS ==========
  
  /**
   * Send Text Message
   * POST /api/send-message
   * Body: { phoneNumber: string, to: string, message: string }
   * Returns: { success: boolean, messageId: string }
   */
  SEND_MESSAGE: (phoneNumber, to, message) => ({
    url: `${API_BASE_URL}/api/send-message`,
    method: 'POST',
    body: { phoneNumber, to, message }
  }),
  
  /**
   * Make Voice Call
   * POST /api/make-call
   * Body: { phoneNumber: string, to: string }
   * Returns: { success: boolean }
   */
  MAKE_CALL: (phoneNumber, to) => ({
    url: `${API_BASE_URL}/api/make-call`,
    method: 'POST',
    body: { phoneNumber, to }
  }),
  
  // ========== ADMIN ENDPOINTS ==========
  
  /**
   * Clear Session State
   * POST /api/clear-state/:phoneNumber?fullReset=false
   * Returns: { success: boolean, message: string }
   */
  CLEAR_STATE: (phoneNumber, fullReset = false) => ({
    url: `${API_BASE_URL}/api/clear-state/${phoneNumber}?fullReset=${fullReset}`,
    method: 'POST'
  }),
  
  /**
   * Health Check
   * GET /health
   * Returns: { status: string, uptime: number }
   */
  HEALTH: () => ({
    url: `${API_BASE_URL}/health`,
    method: 'GET'
  })
};

// Helper function to make API calls
export const callAPI = async (endpoint) => {
  try {
    const response = await fetch(endpoint.url, {
      method: endpoint.method,
      headers: {
        'Content-Type': 'application/json',
      },
      body: endpoint.body ? JSON.stringify(endpoint.body) : undefined
    });
    
    return await response.json();
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
};

// Example usage:
// import { API_ENDPOINTS, callAPI } from './API';
// const result = await callAPI(API_ENDPOINTS.GET_CHATS('2349154347487'));

export default API_ENDPOINTS;
```

---

## PHASE 4: CLEANUP UNNECESSARY FILES

Delete these file types:
- `*.md` (except README.md if it's important)
- `*.log`
- `.env.example` (if exists)
- Any test files not needed in production
- Old backup files
- Unused dependencies

```bash
# Run this cleanup
find . -name "*.md" ! -name "README.md" -type f -delete
find . -name "*.log" -type f -delete
find . -name "*backup*" -type f -delete
find . -name "*old*" -type f -delete
```

---

## PHASE 5: DEPLOY ON REPLIT

### 5.1 Create `.replit` Configuration
```toml
run = "node server.js"
language = "nodejs"

[nix]
channel = "stable-22_11"

[deployment]
run = ["sh", "-c", "node server.js"]
deploymentTarget = "cloudrun"

[[ports]]
localPort = 3000
externalPort = 80
```

### 5.2 Create `replit.nix` 
```nix
{ pkgs }: {
  deps = [
    pkgs.nodejs-18_x
    pkgs.nodePackages.typescript
    pkgs.nodePackages.typescript-language-server
  ];
}
```

### 5.3 Update `package.json`
```json
{
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "./test-endpoints.sh"
  }
}
```

### 5.4 Deploy Steps
1. Click "Deploy" button in Replit
2. Choose "Autoscale" deployment
3. Set environment variables in Secrets tab
4. Click "Deploy"

---

## PHASE 6: ENVIRONMENT CONFIGURATION GUIDE

### 6.1 Adding OpenAI API Key

#### In Replit:
1. Go to "Tools" → "Secrets" (or lock icon in sidebar)
2. Add new secret:
   - Key: `OPENAI_API_KEY`
   - Value: `sk-your-openai-api-key-here`
3. Click "Add Secret"

#### In Code:
```javascript
// Access in your backend
const openai = require('openai');

const openaiClient = new openai.OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});
```

#### In `.env` file (local development):
```bash
OPENAI_API_KEY=sk-your-openai-api-key-here
PORT=3000
NODE_ENV=development
```

### 6.2 All Required Environment Variables
```bash
# OpenAI Configuration
OPENAI_API_KEY=sk-xxxxx

# Server Configuration
PORT=3000
NODE_ENV=production

# WhatsApp Configuration (if needed)
WHATSAPP_SESSION_TIMEOUT=300000

# Optional: Database
DATABASE_URL=your-database-url
```

---

## PHASE 7: ACCESSING REPLIT SHELL & MANUAL STATE MANAGEMENT

### 7.1 Access Shell in Replit
1. Click "Shell" tab at the bottom of Replit
2. Or press `Ctrl + Shift + S` (Windows/Linux) or `Cmd + Shift + S` (Mac)

### 7.2 Manual State Deletion Commands

#### View Current Sessions
```bash
# List all session directories
ls -la auth_info_baileys/

# Check specific session
ls -la auth_info_baileys/2349154347487/
```

#### Delete Sync State Only (Keep Authentication)
```bash
# Delete only sync files - won't require re-authentication
rm auth_info_baileys/2349154347487/app-state-sync-*.json

# Verify deletion
ls auth_info_baileys/2349154347487/
```

#### Complete Session Reset (Requires Re-authentication)
```bash
# Delete entire session folder
rm -rf auth_info_baileys/2349154347487/

# Or delete all sessions
rm -rf auth_info_baileys/
```

#### Emergency Full Reset
```bash
# Stop the server first
pkill node

# Delete all session data
rm -rf auth_info_baileys/

# Create fresh directory
mkdir auth_info_baileys

# Restart server
npm start
```

### 7.3 Monitoring Commands
```bash
# View real-time logs
tail -f logs/app.log

# Check server status
ps aux | grep node

# View port usage
netstat -tuln | grep 3000

# Check disk space
df -h
```

### 7.4 Quick Troubleshooting Commands
```bash
# Restart server
pkill node && npm start

# Clear node cache
npm cache clean --force

# Reinstall dependencies
rm -rf node_modules package-lock.json
npm install

# Check Node version
node --version

# Test endpoint from shell
curl http://localhost:3000/health
```

---

## PHASE 8: FINAL CHECKLIST

Before marking as complete, verify:

- [ ] All endpoints return proper responses (no 500 errors)
- [ ] Status updates endpoint fixed
- [ ] Chats endpoint returns data
- [ ] State clearing functionality works
- [ ] Test script runs successfully
- [ ] API.js file created with all endpoints
- [ ] Unnecessary files deleted
- [ ] Deployed on Replit
- [ ] Environment variables configured
- [ ] Health check endpoint responds
- [ ] Connection/disconnection works
- [ ] Documentation complete

---

## PHASE 9: WAIT FOR USER

After completing all phases:

1. **Report** all endpoints tested with results
2. **Provide** the deployed Replit URL
3. **Share** the API.js file content
4. **List** all working endpoints
5. **Wait** for user to share frontend code for cross-checking
6. **Wait** for user to connect and test manually

**DO NOT PROCEED** until user provides frontend code and confirms they're ready to test!

---

## ADDITIONAL NOTES

### Common Issues & Solutions:

**Issue**: Port already in use
```bash
# Kill process on port 3000
lsof -ti:3000 | xargs kill -9
```

**Issue**: Permission denied
```bash
# Fix file permissions
chmod +x test-endpoints.sh
chmod 755 server.js
```

**Issue**: Module not found
```bash
# Reinstall dependencies
npm install
```

**Issue**: Baileys connection fails
```bash
# Clear all state and reconnect
rm -rf auth_info_baileys/
mkdir auth_info_baileys
```

---

## SUCCESS CRITERIA

✅ Zero 500 errors in logs
✅ All endpoints return JSON responses
✅ Chats load successfully
✅ Status updates work
✅ Connection stable
✅ State management working
✅ Deployed and accessible
✅ Documentation complete
✅ Ready for frontend integration

---

**Agent 3: Execute this task step by step. Report progress after each phase. Wait for user confirmation before final deployment.**